from collections import defaultdict
from typing import List, Dict

import math

from external_explainers.metainsight_explainer.data_pattern import HomogenousDataPattern
from external_explainers.metainsight_explainer.data_pattern import BasicDataPattern
from external_explainers.metainsight_explainer.pattern_evaluations import PatternType

COMMONNESS_THRESHOLD = 0.5
BALANCE_PARAMETER = 1
ACTIONABILITY_REGULARIZER_PARAM = 0.1
EXCEPTION_CATEGORY_COUNT = 3


class MetaInsight:
    """
    Represents a MetaInsight (HDP, commonness_set, exceptions).
    """

    def __init__(self, hdp: HomogenousDataPattern,
                 commonness_set: List[List[BasicDataPattern]],
                 exceptions: Dict[str, List[BasicDataPattern]], score=0,
                 commonness_threshold: float = COMMONNESS_THRESHOLD,
                 balance_parameter: float = BALANCE_PARAMETER,
                 actionability_regularizer_param: float = ACTIONABILITY_REGULARIZER_PARAM,
                 ):
        """
        :param hdp: list of BasicDataPattern objects
        :param commonness_set: A dictionary mapping commonness patterns to lists of BasicDataPattern objects
        :param exceptions: A dictionary mapping exception categories to lists of BasicDataPattern objects
        """
        self.hdp = hdp
        self.commonness_set = commonness_set
        self.exceptions = exceptions
        self.score = score
        self.commonness_threshold = commonness_threshold
        self.balance_parameter = balance_parameter
        self.actionability_regularizer_param = actionability_regularizer_param

    def __repr__(self):
        return f"MetaInsight(score={self.score:.4f}, #HDP={len(self.hdp)}, #Commonness={len(self.commonness_set)}, #Exceptions={len(self.exceptions)})"

    @staticmethod
    def categorize_exceptions(commonness_set, exceptions):
        """
        Categorizes exceptions based on differences from commonness highlights/types.
        Simplified categorization: Highlight-Change, Type-Change, No-Pattern (though No-Pattern
        should ideally not be in the exceptions list generated by generate_hdp).
        Returns a dictionary mapping category names to lists of exception patterns.
        """
        categorized = defaultdict(list)
        commonness_highlights = set()
        for commonness in commonness_set:
            if commonness:  # Ensure commonness is not empty
                commonness_highlights.add(str(commonness[0].highlight))  # Assume all in commonness have same highlight

        for exc_dp in exceptions:
            if exc_dp.pattern_type == PatternType.OTHER:
                categorized['Type-Change'].append(exc_dp)
            elif exc_dp.pattern_type == PatternType.NONE:
                # This case should ideally not happen if generate_hdp filters 'No Pattern'
                categorized['No-Pattern'].append(exc_dp)
            elif str(exc_dp.highlight) not in commonness_highlights:
                categorized['Highlight-Change'].append(exc_dp)

            # Keeping this commented out, since I couldn't figure out what to do with something in this catch-all category.
            # For now it will be ignored, but it could maybe be useful.
            # else:
            #      # Exception has a valid pattern type and highlight, but didn't meet commonness threshold
            #      # This could be another category or grouped with Highlight-Change
            #      categorized['Other-Exception'].append(exc_dp) # Add a catch-all category

        return categorized

    @staticmethod
    def create_meta_insight(hdp: HomogenousDataPattern, commonness_threshold=COMMONNESS_THRESHOLD) -> 'MetaInsight':
        """
        Evaluates the HDP and creates a MetaInsight object.
        :param hdp: A HomogenousDataPattern object.
        :param commonness_threshold: The threshold for commonness.
        :return: A MetaInsight object if possible, None otherwise.
        """
        if len(hdp) == 0:
            return None

        # Group patterns by similarity
        similarity_groups = defaultdict(list)
        for dp in hdp:
            found_group = False
            for key in similarity_groups:
                # Check similarity with the first element of an existing group
                if dp.sim(similarity_groups[key][0]):
                    similarity_groups[key].append(dp)
                    found_group = True
                    break
            if not found_group:
                # Create a new group with this pattern as the first element (key)
                similarity_groups[dp].append(dp)

        # Identify commonness(es) based on the threshold
        commonness_set = []
        exceptions = []
        total_patterns_in_hdp = len(hdp)

        # Need to iterate through the original HDP to ensure all patterns are considered
        # and assigned to either commonness or exceptions exactly once.
        processed_patterns = set()
        for dp in hdp:
            if dp in processed_patterns:
                continue

            is_commonness = False
            for key, group in similarity_groups.items():
                if dp in group:
                    # An equivalence class is a commonness if it contains more than COMMONNESS_THRESHOLD of the HDP
                    if len(group) / total_patterns_in_hdp > commonness_threshold:
                        commonness_set.append(group)
                        for pattern in group:
                            processed_patterns.add(pattern)
                        is_commonness = True
                    break  # Found the group for this pattern

            if not is_commonness:
                # If the pattern wasn't part of a commonness, add it to exceptions
                exceptions.append(dp)
                processed_patterns.add(dp)

        # A valid MetaInsight requires at least one commonness
        if not commonness_set:
            return None

        # Categorize exceptions (optional for basic MetaInsight object, but needed for scoring)
        categorized_exceptions = MetaInsight.categorize_exceptions(commonness_set, exceptions)

        return MetaInsight(hdp, commonness_set, categorized_exceptions, commonness_threshold=commonness_threshold)

    def calculate_conciseness(self) -> float:
        """
        Calculates the conciseness score of a MetaInsight.
        Based on the entropy of category proportions.
        """
        n = len(self.hdp)
        if n == 0:
            return 0

        # Calculate entropy
        S = 0
        commonness_proportions = []
        for patterns in self.commonness_set:
            if len(patterns) > 0:
                proportion = len(patterns) / n
                S += proportion * math.log2(proportion)
                commonness_proportions.append(proportion)

        exception_proportions = []
        for category, patterns in self.exceptions.items():
            if len(patterns) > 0:
                proportion = len(patterns) / n
                S += self.balance_parameter * (proportion * math.log2(proportion))
                exception_proportions.append(proportion)

        # Convert to positive entropy
        S = -S

        # Compute S* (the upper bound of S)
        threshold = ((1 - self.commonness_threshold) * math.e) / (
            math.pow(self.commonness_threshold, 1 / self.balance_parameter))
        if EXCEPTION_CATEGORY_COUNT > threshold:
            S_star = -math.log2(self.commonness_threshold) + (self.balance_parameter * EXCEPTION_CATEGORY_COUNT
                                                              * math.pow(self.commonness_threshold,
                                                                         1 / self.balance_parameter)
                                                              * math.log2(math.e))
        else:
            S_star = - self.commonness_threshold * math.log(self.commonness_threshold) - (
                    self.balance_parameter * (1 - self.commonness_threshold) * math.log2(
                (1 - self.commonness_threshold) / EXCEPTION_CATEGORY_COUNT)
            )

        indicator_value = 1 if len(exception_proportions) == 0 else 0
        conciseness = 1 - ((S + self.actionability_regularizer_param * indicator_value) / S_star)

        # Ensure conciseness is within a reasonable range, e.g., [0, 1]
        return conciseness

    def compute_score(self, cache) -> float:
        """
        Computes the score of the MetaInsight.
        The score is the multiple of the conciseness of the MetaInsight and the impact score of the HDS
        making up the HDP.
        :param impact_measure: The impact measure to be used for the HDS.
        :return: The score of the MetaInsight.
        """
        conciseness = self.calculate_conciseness()
        # If the impact has already been computed, use it
        hds_score = self.hdp.impact if self.hdp.impact != 0 else self.hdp.compute_impact(cache)
        self.score = conciseness * hds_score
        return self.score

    def compute_pairwise_overlap_ratio(self, other: 'MetaInsight') -> float:
        """
        Computes the pairwise overlap ratio between two MetaInsights, as the ratio between the
        size of the intersection and the size of the union of their HDPs.
        :param other: Another MetaInsight object to compare with.
        :return: The overlap ratio between the two MetaInsights.
        """
        if not isinstance(other, MetaInsight):
            raise ValueError("The other object must be an instance of MetaInsight.")
        hds_1 = set(self.hdp.data_scopes)
        hds_2 = set(other.hdp.data_scopes)

        overlap = len(hds_1.intersection(hds_2))
        total = len(hds_1.union(hds_2))
        # Avoid division by 0
        if total == 0:
            return 0.0
        return overlap / total

    def compute_pairwise_overlap_score(self, other: 'MetaInsight') -> float:
        """
        Computes the pairwise overlap score between two MetaInsights.
        This is computed as min(I_1.score, I_2.scor) * overlap_ratio(I_1, I_2)
        :param other: Another MetaInsight object to compare with.
        :return: The pairwise overlap score between the two MetaInsights.
        """
        if not isinstance(other, MetaInsight):
            raise ValueError("The other object must be an instance of MetaInsight.")
        overlap_ratio = self.compute_pairwise_overlap_ratio(other)
        return min(self.score, other.score) * overlap_ratio

    def visualize(self, plt_ax) -> None:
        """
        Visualize the metainsight - both its commonness and exceptions.
        :param plt_ax: The matplotlib axis to plot on.
        :return:
        """
        len_commoness = len(self.commonness_set)
        len_exceptions = len(self.exceptions)
        # Split the axes in 2: one for commonness, one for exceptions
        if len_commoness >= 1 and len_exceptions >= 1:
            pass
